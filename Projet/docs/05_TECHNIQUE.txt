// TECHNIQUE - Dream Island //

* Objectif *

Ce document décrit la structure et le fonctionnement interne du code de Dream Island, afin de les modifications du projet (et tout ce qui va avec)
Les concepts de gameplay, indicateurs et bâtiments sont expliqués dans `01_GAMEPLAY.txt` et `03_BATIMENTS.txt`. Ici, ils ne sont mentionnés que brièvement pour référence.


* Architecture du projet *

	* Arborescence

```
DreamIsland/
├── main.py            ← point d’entrée et boucle principale
├── /src/              ← modules Python
│   ├── game.py        ← logique de jeu, progression et mise à jour des systèmes
│   ├── island.py      ← carte de l’île et placement/suppression de bâtiments
│   ├── buildings.py   ← classes et effets des bâtiments
│   ├── events.py      ← génération et application des événements
│   ├── interface.py   ← affichage et interaction via Pyxel
│   └── save_load.py   ← sauvegarde et chargement JSON
├── /assets/           ← images, sprites, sons
├── /saves/            ← fichiers de sauvegarde
└── /docs/             ← documentation complète
```


* Classes principales et rôle *

| Classe      | Description                                                                                  |
| ----------- | -------------------------------------------------------------------------------------------- |
| `Game`      | Boucle principale, gestion de la progression et coordination des systèmes                    |
| `Island`    | Grille 2D représentant l’île et gestion du placement des bâtiments                           |
| `Building`  | Définition des bâtiments et application de leurs effets (référencés dans `03_BATIMENTS.txt`) |
| `Event`     | Gestion des événements aléatoires et de leur impact                                          |
| `Interface` | Affichage, menus, boutons et fenêtres d’information via Pyxel                                |
| `SaveLoad`  | Sérialisation et restauration de l’état du jeu en JSON                                       |


* Fonctionnement principal *

   * Boucle de jeu

- Temps réel avec un tick régulier.
- Chaque tick :

  * Mise à jour des systèmes et indicateurs (argent, pollution, population…)
  * Application des effets cumulés des bâtiments et événements
  * Rafraîchissement de l’interface
  * Vérification des conditions de progression et niveaux

  * Gestion des collisions et placement

- Vérification des cases disponibles avant placement.
- Empêche le chevauchement de bâtiments.

  * Sauvegarde et chargement

- Sauvegarde automatique de l’état du jeu :

  * Bâtiments et positions
  * État des systèmes
  * Progression du joueur et événements actifs

- Utilisation de JSON pour la sauvegarde


* Extensions prévues *

- Ajout de nouveaux bâtiments et catégories.
- Intégration possible de quêtes ou missions liées aux événements.


